# Proto-Common Integration for Event-Driven Architecture

**Status**: Design Document  
**Last Updated**: November 13, 2024  
**Related**: [EVENT_DRIVEN_RTE_PLAN.md](EVENT_DRIVEN_RTE_PLAN.md), [DIGITAL_SESSION_PLATFORM_PLAN.md](DIGITAL_SESSION_PLATFORM_PLAN.md)

---

## Overview

This document specifies how to integrate the event-driven architecture with IncludedHealth's existing proto-common patterns, protostore event emission, and domain event standards. **All new events must follow these established patterns rather than defining custom schemas.**

---

## Table of Contents

1. [Protostore Event Emission Pattern](#1-protostore-event-emission-pattern)
2. [Standard Event Components](#2-standard-event-components)
3. [Domain Event Definition Pattern](#3-domain-event-definition-pattern)
4. [Safe Harbor Annotations for PHI/PII](#4-safe-harbor-annotations-for-phipii)
5. [Event Gateway Integration](#5-event-gateway-integration)
6. [RTE Domain Events](#6-rte-domain-events)
7. [Digital Session Events](#7-digital-session-events)
8. [Care Operations Events](#8-care-operations-events)
9. [Migration from CloudEvents](#9-migration-from-cloudevents)
10. [Code Generation](#10-code-generation)

---

## 1. Protostore Event Emission Pattern

### How Protostore Automatically Emits Events

**Pattern**: Protostore automatically generates `*Changed` events for all entities with the `protostore` annotation. These events are emitted to Kafka on every create/update/delete operation.

### Example: RTE Log Change Event

**Entity Definition**:
```protobuf
// domain/coverage/realtime_eligibility/v1/realtime_eligibility_log.proto
syntax = "proto3";

package domain.coverage.realtime_eligibility.v1;

import "annotations/v1/annotations.proto";

message RealtimeEligibilityLog {
  option (annotations.v1.entity) = {};
  option (annotations.v1.protostore) = {
    db_indexes: [
      {path: "account_id", index_type: BTREE},
      {path: "checksum", index_type: BTREE}
    ]
  };

  string id = 1;
  string account_id = 4;
  string raw_request = 2 [(annotations.v1.safe_harbor) = OPEN_TEXT_FIELD];
  optional string raw_response = 3 [(annotations.v1.safe_harbor) = OPEN_TEXT_FIELD];
  // ... more fields
}
```

**Auto-Generated Change Event**:
```protobuf
// domain/coverage/realtime_eligibility/v1/realtime_eligibility_log_change.proto
// Code generated by a tool. DO NOT EDIT.

message RealtimeEligibilityLogChanged {
  message Patch {
    RealtimeEligibilityLog patch = 1;
    google.protobuf.FieldMask field_mask = 2;
  }

  string id = 1;
  google.protobuf.Timestamp ts = 2;

  oneof operation {
    RealtimeEligibilityLog created = 3;
    Patch patch = 4;
    shared.protostore.v1.Delete delete = 5;
  }
}
```

### Kafka Topic Pattern

**Convention**: `domain-events.<package_name>.<entity_name>-changed`

Examples:
- `domain-events.domain.coverage.realtime_eligibility.v1.realtime-eligibility-log-changed`
- `domain-events.domain.care_operations.orchestration.v1.service-request-changed`
- `domain-events.domain.member_sponsorship.sponsorship.v1.sponsorship-changed`

### Best Practices

1. ✅ **DO**: Use protostore for entity persistence (automatic event emission to Kafka)
2. ✅ **DO**: Define domain entities in `proto-common/domain/<domain>/<subdomain>/v1/`
3. ✅ **DO**: Add `(annotations.v1.entity) = {}` to all domain entities
4. ✅ **DO**: Add `(annotations.v1.protostore) = {}` with DB indexes to persisted entities
5. ❌ **DON'T**: Manually emit events for protostore entities (redundant, inconsistent)
6. ❌ **DON'T**: Define custom change event schemas (use generated `*Changed` messages)

---

## 2. Standard Event Components

### shared.events.v1.Header

**Usage**: Standard header for ALL domain events (both protostore and custom events)

```protobuf
// shared/events/v1/header.proto
message Header {
  // The UUID of the event
  string event_uuid = 1;
  
  // The timestamp for when the event occurred
  google.protobuf.Timestamp timestamp = 2;
  
  // The open telemetry trace ID of the request that triggered the event
  string trace_id = 3;
  
  // The services which initiated or interacted with this event
  Provenance provenance = 4;
  
  // The device ID of the client emitting the event
  optional string device_id = 5;
}
```

### shared.events.v1.Provenance

**Purpose**: Track service lineage and interactions with an event

```protobuf
// shared/events/v1/provenance.proto
message Provenance {
  // The deployed service which is the ultimate origin of the event
  ServiceInfo origin = 1;
  
  // All services who have had interactions with this event
  repeated Interaction interactions = 2;
}

message Interaction {
  ServiceInfo service_info = 1;
  google.protobuf.Timestamp timestamp = 2;
}

message ServiceInfo {
  string name = 1;          // e.g. "coverage-server"
  string app_name = 2;      // e.g. "app"
  string version = 3;       // commit SHA
}
```

**Example Usage**:
```go
provenance := &eventspb.Provenance{
    Origin: &eventspb.ServiceInfo{
        Name:    "realtime-eligibility",
        AppName: "app",
        Version: os.Getenv("GIT_SHA"),
    },
    Interactions: []*eventspb.Interaction{
        {
            ServiceInfo: &eventspb.ServiceInfo{
                Name:    "coverage-server",
                AppName: "app",
                Version: "abc123",
            },
            Timestamp: timestamppb.Now(),
        },
    },
}
```

---

## 3. Domain Event Definition Pattern

### Pattern: Custom Domain Events (Non-Protostore)

For events that **are NOT** tied to protostore entity mutations (e.g., user actions, system events), define custom domain events following this pattern:

**Example: Member Authentication Event**

```protobuf
// domain/authentication/v1/member_authn_event.proto
syntax = "proto3";

package domain.authentication.v1;

import "annotations/v1/annotations.proto";
import "shared/events/v1/header.proto";

// An event triggered when a member interacts with our authentication systems
message MemberAuthnEvent {
  // The header of the event
  shared.events.v1.Header header = 1;
  
  // Type of authentication event
  EventType type = 2;
  
  // Whether the event represents success or failure
  bool success = 3;
  
  // The type of credentials used
  CredentialType credential_type = 4;
  
  // IH Account ID of the member (may be empty)
  string account_id = 5;
  
  // Member identity in auth service (safe harbor: OPEN_TEXT_FIELD for legacy IDs)
  string login_id = 6 [(annotations.v1.safe_harbor) = OPEN_TEXT_FIELD];
  
  // Member's email (safe harbor: EMAIL)
  string email = 7 [(annotations.v1.safe_harbor) = EMAIL];
  
  // Hashed login_id for joins (sha-224)
  string hashed_login_id = 13;
  
  enum EventType {
    UNSPECIFIED = 0;
    SIGNIN = 1;
    SESSION_REFRESH = 2;
    LOGOUT = 5;
    PASSWORD_RESET_REQUEST = 6;
    PASSWORD_RESET = 7;
  }
  
  enum CredentialType {
    CT_UNSPECIFIED = 0;
    USERNAME_PASSWORD = 1;
    INBOUND_SSO = 2;
    SOCIAL = 3;
  }
}
```

**Kafka Topic**: `domain-events.domain.authentication.v1.member-authn-event`

---

## 4. Safe Harbor Annotations for PHI/PII

### Available Annotations

From `annotations/v1/safe_harbor.proto`:

```protobuf
enum SafeHarbor {
  UNSPECIFIED = 0;
  
  // Personal identifiers
  FULL_NAME = 1;
  FIRST_NAME = 2;
  MIDDLE_NAME = 29;
  LAST_NAME = 3;
  
  // Contact information
  ADDRESS = 4;
  CITY = 5;
  STATE = 6;
  ZIP = 7;
  PHONE = 11;
  FAX = 12;
  EMAIL = 13;
  
  // Dates
  BIRTH_DATE = 8;
  SERVICE_DATE = 9;
  OTHER_DATE = 10;
  
  // Identifiers
  SSN = 14;
  SSN_LAST_4 = 15;
  MEDICAL_RECORD_NUMBER = 16;
  HEALTH_PLAN_NUMBER = 17;
  ACCOUNT_NUMBER = 18;
  LICENSE_NUMBER = 19;
  VEHICLE_NUMBER = 20;
  DEVICE_SERIAL_NUMBER = 21;
  UNIQUE_ID = 26;
  CC_LAST_4 = 30;
  
  // Other
  URL = 22;
  IP_ADDRESS = 23;
  BIOMETRIC = 24;
  PHOTOGRAPH = 25;
  
  // IH-specific
  OPEN_TEXT_FIELD = 27;       // For unstructured text (notes, comments)
  PLACEHOLDER_SCRUB = 28;     // Not yet analyzed, scrub by default
}
```

### Usage Pattern

**Rule**: Every field containing PHI/PII **MUST** have a `safe_harbor` annotation.

```protobuf
message CareTaskEvent {
  shared.events.v1.Header header = 1;
  
  // No annotation: non-PHI
  string task_id = 2;
  TaskStatus status = 3;
  
  // Safe Harbor annotations for PHI
  string member_name = 4 [(annotations.v1.safe_harbor) = FULL_NAME];
  string member_email = 5 [(annotations.v1.safe_harbor) = EMAIL];
  string assignee_name = 6 [(annotations.v1.safe_harbor) = FULL_NAME];
  string notes = 7 [(annotations.v1.safe_harbor) = OPEN_TEXT_FIELD];
  
  // Hashed identifiers for joins (no PHI)
  string hashed_member_id = 8;
}
```

### Why This Matters

1. **Audit Logging**: Fields marked with `safe_harbor` are redacted in non-production logs
2. **HIPAA Compliance**: Automatic tracking of PHI access patterns
3. **Data Governance**: Querybook/Lasik export respects safe harbor annotations
4. **Break Glass**: PHI fields require elevated access to view in production

---

## 5. Event Gateway Integration

### Pattern: For Services Without Protostore

If your service **does NOT use protostore** but needs to emit domain events:

**Use Event Gateway** (recommended by platform team):

```go
import (
    "github.com/ConsultingMD/proto-common/go/pkg/service/eventgateway/v1"
)

// Initialize Event Gateway client
eventGatewayClient := eventgatewayv1.NewEventGatewayServiceClient(conn)

// Emit custom domain event
event := &authenticationv1.MemberAuthnEvent{
    Header: &eventspb.Header{
        EventUuid: uuid.New().String(),
        Timestamp: timestamppb.Now(),
        TraceId:   trace.SpanContextFromContext(ctx).TraceID().String(),
        Provenance: buildProvenance(),
        DeviceId:  deviceID,
    },
    Type:           authenticationv1.MemberAuthnEvent_SIGNIN,
    Success:        true,
    CredentialType: authenticationv1.MemberAuthnEvent_USERNAME_PASSWORD,
    AccountId:      accountID,
    Email:          email,
}

// Event Gateway handles Kafka async write + retries
_, err := eventGatewayClient.PublishEvents(ctx, &eventgatewayv1.PublishEventsRequest{
    Events: []*eventgatewayv1.Event{
        {
            Topic:   "domain-events.domain.authentication.v1.member-authn-event",
            Key:     accountID,  // Partition key
            Payload: marshalProto(event),
        },
    },
})
```

### Event Gateway Benefits

1. **Async Kafka Write**: Non-blocking with retry logic
2. **At-Least-Once Delivery**: Guarantees event emission even on transient failures
3. **Observability**: Metrics, logs, traces for event publishing
4. **Backpressure Handling**: Circuit breaker on Kafka outages

### When to Use What

| Pattern | Use Case | Example |
|---------|----------|---------|
| **Protostore** | Entity persistence + change events | `RealtimeEligibilityLog`, `ServiceRequest`, `MedicationRequest` |
| **Event Gateway** | Custom domain events (no entity) | `MemberAuthnEvent`, `ButtonClickedEvent`, `CacheWarmingTriggered` |
| **Direct Kafka** | High-throughput internal events | Agent platform streaming chunks (NOT domain events) |

---

## 6. RTE Domain Events

### Existing RTE Events in Proto-Common

```
proto-common/domain/coverage/realtime_eligibility/v1/
├── realtime_eligibility_log.proto          # Entity
├── realtime_eligibility_log_change.proto   # Auto-generated change event
├── realtime_eligibility_poll_status.proto  # Polling status entity
└── service.proto                            # RPC service definition
```

### New RTE Events (from EVENT_DRIVEN_RTE_PLAN.md)

**Location**: `proto-common/domain/coverage/realtime_eligibility/v1/`

**1. RTE Request Initiated Event**

```protobuf
syntax = "proto3";

package domain.coverage.realtime_eligibility.v1;

import "annotations/v1/annotations.proto";
import "shared/events/v1/header.proto";

// Emitted when RTE request is initiated (before Stedi call)
message RTERequestInitiatedEvent {
  shared.events.v1.Header header = 1;
  
  // Request identifiers
  string request_id = 2;          // Unique request ID
  string account_id = 3;           // Member account ID
  
  // Payer/service info
  string trading_partner_id = 4;
  repeated string service_types = 5;
  
  // Client context
  string originating_service = 6;  // e.g. "coverage-server"
  string request_path = 7;         // GraphQL operation or RPC method
  bool is_frontend_request = 8;    // User-facing vs batch
  
  // Timing
  google.protobuf.Timestamp initiated_at = 9;
}
```

**Kafka Topic**: `domain-events.domain.coverage.realtime-eligibility.v1.rte-request-initiated-event`

**2. RTE Request Completed Event**

```protobuf
// Emitted when RTE request completes (success or failure)
message RTERequestCompletedEvent {
  shared.events.v1.Header header = 1;
  
  // Request identifiers
  string request_id = 2;
  string account_id = 3;
  
  // Outcome
  RTEOutcome outcome = 4;
  optional string error_code = 5;      // Stedi DTE error code (80, 42, etc.)
  optional string error_message = 6 [(annotations.v1.safe_harbor) = OPEN_TEXT_FIELD];
  
  // Response data
  optional string rte_log_id = 7;      // FK to RealtimeEligibilityLog
  bool has_active_coverage = 8;
  
  // Timing (for P95/P99 metrics)
  google.protobuf.Timestamp completed_at = 9;
  int64 duration_ms = 10;
  int64 stedi_duration_ms = 11;        // Time in Stedi API call
  
  enum RTEOutcome {
    UNSPECIFIED = 0;
    SUCCESS = 1;
    CACHE_HIT = 2;
    COLLAPSED_REQUEST = 3;     // Request deduplicated
    ERROR_TIMEOUT = 4;
    ERROR_RATE_LIMIT = 5;
    ERROR_STEDI = 6;
  }
}
```

**Kafka Topic**: `domain-events.domain.coverage.realtime-eligibility.v1.rte-request-completed-event`

**3. RTE Cache Warming Event**

```protobuf
// Emitted by Digital Twin when cache warming is triggered
message RTECacheWarmingEvent {
  shared.events.v1.Header header = 1;
  
  // Trigger source
  string prediction_id = 2;        // ML prediction that triggered warming
  PredictionType prediction_type = 3;
  
  // Target member
  string account_id = 4;
  
  // Payer list
  repeated string trading_partner_ids = 5;
  
  // Timing
  google.protobuf.Timestamp predicted_access_time = 6;  // When member expected to need RTE
  int32 warmup_window_minutes = 7;                      // How early to warm cache
  
  enum PredictionType {
    UNSPECIFIED = 0;
    APP_USAGE_LIKELY = 1;         // Member likely to open app
    CARE_GAP_LIKELY = 2;          // Member likely to engage with care gap
    FIND_CARE_LIKELY = 3;         // Member likely to search for provider
    VIRTUAL_VISIT_LIKELY = 4;     // Member likely to start video visit
  }
}
```

**Kafka Topic**: `domain-events.domain.coverage.realtime-eligibility.v1.rte-cache-warming-event`

### Integration with Existing `RealtimeEligibilityLog`

**Pattern**: `RTERequestCompletedEvent.rte_log_id` is a **foreign key reference** to `RealtimeEligibilityLog.id`.

```protobuf
message RTERequestCompletedEvent {
  // ...
  
  // FK reference to persisted RTE log
  optional string rte_log_id = 7 [(annotations.v1.reference) = {
    entity_type: "domain.coverage.realtime_eligibility.v1.RealtimeEligibilityLog"
  }];
}
```

This allows:
1. **Separation of concerns**: Fast event stream (completed event) vs slow persistence (log entity)
2. **Audit trail**: Link event to raw Stedi request/response in protostore
3. **Join queries**: Lasik can join events with RTE logs on `rte_log_id`

---

## 7. Digital Session Events

### New Digital Session Events

**Location**: `proto-common/domain/member_experience/digital_session/v1/`

**1. Digital Session Event**

```protobuf
syntax = "proto3";

package domain.member_experience.digital_session.v1;

import "annotations/v1/annotations.proto";
import "shared/events/v1/header.proto";

// Emitted when a member's digital session state changes
message DigitalSessionEvent {
  shared.events.v1.Header header = 1;
  
  // Session identifiers
  string session_id = 2;           // Unique session ID
  string account_id = 3;
  
  // Session lifecycle
  SessionEvent event_type = 4;
  
  // Client context
  ClientPlatform platform = 5;
  string app_version = 6;
  optional string device_id = 7;
  
  // Session state
  google.protobuf.Timestamp session_started_at = 8;
  optional google.protobuf.Timestamp session_ended_at = 9;
  
  // Screen/route context
  optional string current_screen = 10;  // e.g. "home", "find_care", "care_gap_detail"
  optional string previous_screen = 11;
  
  enum SessionEvent {
    UNSPECIFIED = 0;
    SESSION_STARTED = 1;
    SESSION_RESUMED = 2;
    SCREEN_VIEWED = 3;
    SESSION_ENDED = 4;
  }
  
  enum ClientPlatform {
    PLATFORM_UNSPECIFIED = 0;
    WEB = 1;
    IOS = 2;
    ANDROID = 3;
    CARE_APP_WEB = 4;
  }
}
```

**Kafka Topic**: `domain-events.domain.member-experience.digital-session.v1.digital-session-event`

**2. Member Action Event**

```protobuf
// Emitted when a member performs an action in the app
message MemberActionEvent {
  shared.events.v1.Header header = 1;
  
  // Session context
  string session_id = 2;
  string account_id = 3;
  
  // Action details
  ActionType action_type = 4;
  string action_target = 5;        // e.g. "find_care_button", "care_gap_12345"
  optional string screen = 6;
  
  // Action metadata
  google.protobuf.Timestamp action_at = 7;
  map<string, string> action_data = 8;  // Flexible metadata
  
  enum ActionType {
    UNSPECIFIED = 0;
    BUTTON_CLICKED = 1;
    LINK_CLICKED = 2;
    FORM_SUBMITTED = 3;
    SEARCH_PERFORMED = 4;
    FILTER_APPLIED = 5;
    ITEM_SELECTED = 6;
  }
}
```

**Kafka Topic**: `domain-events.domain.member-experience.digital-session.v1.member-action-event`

---

## 8. Care Operations Events

### Existing Care Operations Events in Proto-Common

```
proto-common/domain/care_operations/orchestration/v1/
├── service_request.proto                    # Entity (CareFlow Service Request)
├── service_request_change.proto             # Auto-generated change event
├── service_request_mutation.proto           # Mutation wrapper with Header
├── service_delivery.proto                   # Entity (CareFlow Service Delivery)
├── service_delivery_change.proto            # Auto-generated change event
└── service_delivery_mutation.proto          # Mutation wrapper with Header
```

### Mutation Pattern (for External SoR Integration)

**Pattern**: Wrap `*Changed` events with `shared.events.v1.Header` for external integration.

```protobuf
// service_request_mutation.proto
syntax = "proto3";

package domain.care_operations.orchestration.v1;

import "domain/care_operations/orchestration/v1/service_request_change.proto";
import "shared/events/v1/header.proto";

// ServiceRequestMutation describes a mutation from external SoR
// Example: Backfill from Salesforce, Epic integration
message ServiceRequestMutation {
  // The header of the event
  shared.events.v1.Header header = 1;
  
  // The change event that should be applied
  ServiceRequestChanged change = 2;
}
```

**Use Case**: When CareFlow receives Service Request updates from Epic or Salesforce, wrap the change event with provenance/trace context.

### New Care Operations Events (from CARE_APP_REALTIME_COLLABORATION.md)

**1. Task Presence Event**

```protobuf
syntax = "proto3";

package domain.care_operations.collaboration.v1;

import "annotations/v1/annotations.proto";
import "shared/events/v1/header.proto";

// Emitted when a practitioner views or edits a task
message TaskPresenceEvent {
  shared.events.v1.Header header = 1;
  
  // Task identifiers
  string service_request_id = 2;   // FK to ServiceRequest
  string service_delivery_id = 3;  // FK to ServiceDelivery (if exists)
  
  // Practitioner context
  string practitioner_id = 4;
  string practitioner_name = 5 [(annotations.v1.safe_harbor) = FULL_NAME];
  
  // Presence state
  PresenceAction action = 6;
  google.protobuf.Timestamp timestamp = 7;
  
  // Optional: editing context
  optional string editing_field = 8;  // e.g. "notes", "status", "priority"
  
  enum PresenceAction {
    UNSPECIFIED = 0;
    VIEWING = 1;          // Practitioner opened task
    EDITING = 2;          // Practitioner focused on field
    IDLE = 3;             // Practitioner inactive for 30s
    LEFT = 4;             // Practitioner navigated away
  }
}
```

**Kafka Topic**: `domain-events.domain.care-operations.collaboration.v1.task-presence-event`

**2. Task Assignment Event**

```protobuf
// Emitted when a task is assigned/reassigned
message TaskAssignmentEvent {
  shared.events.v1.Header header = 1;
  
  // Task identifiers
  string service_request_id = 2;
  
  // Assignment details
  optional string previous_assignee_id = 3;
  string new_assignee_id = 4;
  string assigned_by_practitioner_id = 5;
  
  // Context
  AssignmentReason reason = 6;
  optional string reason_description = 7;
  
  google.protobuf.Timestamp assigned_at = 8;
  
  enum AssignmentReason {
    UNSPECIFIED = 0;
    MANUAL_ASSIGNMENT = 1;
    AUTO_ROUTED = 2;
    WORKLOAD_BALANCING = 3;
    ESCALATION = 4;
    REASSIGNMENT_REQUESTED = 5;
  }
}
```

**Kafka Topic**: `domain-events.domain.care-operations.collaboration.v1.task-assignment-event`

---

## 9. Migration from CloudEvents

### Current State (in EVENT_DRIVEN_RTE_PLAN.md)

The current plan references **CloudEvents 1.0** format:

```json
{
  "specversion": "1.0",
  "type": "com.includedhealth.rte.request.completed",
  "source": "realtime-eligibility",
  "id": "uuid",
  "time": "2025-01-15T10:30:00Z",
  "datacontenttype": "application/protobuf",
  "data": "<protobuf bytes>"
}
```

### ❌ Problem: CloudEvents Not Used at IncludedHealth

**Findings**:
1. IncludedHealth does NOT use CloudEvents standard
2. All events are **native Protobuf messages** emitted to Kafka
3. Protostore uses auto-generated `*Changed` events
4. Custom events use `shared.events.v1.Header` for metadata

### ✅ Solution: Replace CloudEvents with Proto-Common Pattern

**Migration Steps**:

1. **Replace CloudEvents wrapper with `shared.events.v1.Header`**:

**Before (CloudEvents)**:
```json
{
  "specversion": "1.0",
  "type": "com.includedhealth.rte.request.completed",
  "source": "realtime-eligibility",
  "id": "uuid",
  "time": "2025-01-15T10:30:00Z",
  "data": {
    "request_id": "req_123",
    "account_id": "A123456",
    "outcome": "SUCCESS"
  }
}
```

**After (Proto-Common)**:
```protobuf
message RTERequestCompletedEvent {
  shared.events.v1.Header header = 1;  // Contains: event_uuid, timestamp, trace_id, provenance
  
  string request_id = 2;
  string account_id = 3;
  RTEOutcome outcome = 4;
  // ... more fields
}
```

2. **Update Kafka serialization**:

**Before**: CloudEvents JSON wrapper → Protobuf data
**After**: Native Protobuf serialization (Confluent Schema Registry)

3. **Update event emission code**:

**Before**:
```go
// CloudEvents wrapper
event := cloudevents.NewEvent()
event.SetType("com.includedhealth.rte.request.completed")
event.SetSource("realtime-eligibility")
event.SetData("application/protobuf", protoData)
```

**After**:
```go
// Native proto with Header
event := &rtev1.RTERequestCompletedEvent{
    Header: &eventspb.Header{
        EventUuid:  uuid.New().String(),
        Timestamp:  timestamppb.Now(),
        TraceId:    trace.SpanContextFromContext(ctx).TraceID().String(),
        Provenance: buildProvenance(),
    },
    RequestId:  requestID,
    AccountId:  accountID,
    Outcome:    rtev1.RTERequestCompletedEvent_SUCCESS,
}

// Emit via Event Gateway or protostore
```

### Header Field Mapping

| CloudEvents Field | Proto-Common Equivalent |
|-------------------|-------------------------|
| `id` | `header.event_uuid` |
| `time` | `header.timestamp` |
| `source` | `header.provenance.origin.name` |
| `type` | Protobuf message type (e.g., `RTERequestCompletedEvent`) |
| `subject` | Entity ID field (e.g., `account_id`) |
| `traceparent` | `header.trace_id` |

---

## 10. Code Generation

### Protostore Code Generation

**Location**: `proto-common/` (mono-repo for all proto definitions)

**Run Codegen**:
```bash
cd proto-common
make generate
```

**Generates**:
1. `*_change.proto` - Change events for entities with `(annotations.v1.protostore)`
2. Go clients/servers for RPC services
3. TypeScript, Swift, Kotlin clients for mobile/web

### Example: Adding New RTE Event

**1. Define proto in `proto-common/domain/coverage/realtime_eligibility/v1/`**:

```protobuf
// rte_cache_warming_event.proto
syntax = "proto3";

package domain.coverage.realtime_eligibility.v1;

import "annotations/v1/annotations.proto";
import "shared/events/v1/header.proto";

message RTECacheWarmingEvent {
  shared.events.v1.Header header = 1;
  string prediction_id = 2;
  string account_id = 3;
  repeated string trading_partner_ids = 4;
  google.protobuf.Timestamp predicted_access_time = 5;
}
```

**2. Run codegen**:
```bash
cd proto-common
make generate
```

**3. Import in Go service**:
```go
import (
    rtev1 "github.com/ConsultingMD/proto-common/go/pkg/domain/coverage/realtime_eligibility/v1"
    eventspb "github.com/ConsultingMD/proto-common/go/pkg/shared/events/v1"
)
```

**4. Import in TypeScript frontend**:
```typescript
import { RTECacheWarmingEvent } from '@includedhealth/proto-common/domain/coverage/realtime_eligibility/v1';
```

---

## Implementation Checklist

### Phase 1: Proto-Common Event Definitions

- [ ] Define RTE events in `proto-common/domain/coverage/realtime_eligibility/v1/`
  - [ ] `rte_request_initiated_event.proto`
  - [ ] `rte_request_completed_event.proto`
  - [ ] `rte_cache_warming_event.proto`
- [ ] Define Digital Session events in `proto-common/domain/member_experience/digital_session/v1/`
  - [ ] `digital_session_event.proto`
  - [ ] `member_action_event.proto`
- [ ] Define Care Operations events in `proto-common/domain/care_operations/collaboration/v1/`
  - [ ] `task_presence_event.proto`
  - [ ] `task_assignment_event.proto`
- [ ] Run codegen: `cd proto-common && make generate`
- [ ] Open PR in `proto-common` repo

### Phase 2: Service Integration

- [ ] **RTE Service**: Emit `RTERequestInitiatedEvent` and `RTERequestCompletedEvent`
  - [ ] Replace CloudEvents references with proto-common events
  - [ ] Add `shared.events.v1.Header` to all events
  - [ ] Emit via Event Gateway (not protostore for custom events)
- [ ] **Digital Twin Service**: Emit `RTECacheWarmingEvent` on ML predictions
- [ ] **Coverage Server**: Subscribe to RTE events, forward to WebSocket Gateway
- [ ] **Care Operations Service**: Emit `TaskPresenceEvent` and `TaskAssignmentEvent`

### Phase 3: Documentation Updates

- [ ] Update `EVENT_DRIVEN_RTE_PLAN.md` to reference proto-common events
- [ ] Update `DIGITAL_SESSION_PLATFORM_PLAN.md` to reference proto-common events
- [ ] Update `CARE_APP_REALTIME_COLLABORATION.md` to reference proto-common events
- [ ] Update `ACCESS_CONTROL_DESIGN.md` to use `safe_harbor` annotations
- [ ] Add proto-common references to `EVENT_DRIVEN_INDEX.md`

---

## References

### Proto-Common Documentation

- **Internal Docs**: `proto-common/docs/guide.md`
- **RPC Guide**: `proto-common/docs/rpc.md`
- **Protostore**: `proto-common/docs/protostore/v1/`
- **Schemas**: `proto-common/docs/schemas.md`

### Existing Event Patterns

- **Authentication Events**: `proto-common/domain/authentication/v1/member_authn_event.proto`
- **RTE Events**: `proto-common/domain/coverage/realtime_eligibility/v1/`
- **Care Operations Events**: `proto-common/domain/care_operations/orchestration/v1/`
- **Sponsorship Events**: `proto-common/domain/member_sponsorship/sponsorship/v1/`

### Related Plans

- [EVENT_DRIVEN_RTE_PLAN.md](EVENT_DRIVEN_RTE_PLAN.md) - RTE event-driven architecture
- [DIGITAL_SESSION_PLATFORM_PLAN.md](DIGITAL_SESSION_PLATFORM_PLAN.md) - Digital Session events
- [CARE_APP_REALTIME_COLLABORATION.md](CARE_APP_REALTIME_COLLABORATION.md) - Care App events
- [ACCESS_CONTROL_DESIGN.md](ACCESS_CONTROL_DESIGN.md) - Authorization and PHI handling

---

**Next Steps**: Open PR in `proto-common` to add new event definitions, then update service implementations to emit/consume these events.

